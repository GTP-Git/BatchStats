

# BatchStats.py
# B - proof of concept setup
# 14JUN25
# Refactored to layered architecture
# Schema updated 07JUN25


'''
###############################################################
###############################################################


--- Schema Start ---
'sgs_version': (str): "1.0"
'player_names': (list, 2 items):
(str): "AI 1"
(str): "AI 2"
'sgs_initial_bag': (list, 100 items):
(str): "D"
(str): "X"
(str): "O"
    ... (and 97 more items)
'initial_racks_sgs': (list, 2 items):
(list, 7 items):
(str): "L"
(str): "A"
(str): "I"
      ... (and 4 more items)
(list, 7 items):
(str): "R"
(str): "W"
(str): "D"
      ... (and 4 more items)
'full_move_history': (list, 24 items):
    'player': (int): 1
    'move_type': (str): "place"
    'rack': (list, 7 items):
(str): "L"
(str): "A"
(str): "I"
        ... (and 4 more items)
    'score': (int): 22
    'word': (str): "JILL"
    'positions': (list, 4 items):
(tuple, 3 items):
(int): 7
(int): 7
(str): "J"
(tuple, 3 items):
(int): 7
(int): 8
(str): "I"
(tuple, 3 items):
(int): 7
(int): 9
(str): "L"
        ... (and 1 more items)
    'blanks': (set): set() (empty)
    'drawn': (list, 4 items):
(str): "T"
(str): "A"
(str): "V"
        ... (and 1 more items)
    'coord': (str): "8H"
    'word_with_blanks': (str): "JILL"
    'is_bingo': (bool): False
    'turn_duration': (float): 0.0
    'total_expected_draw_value': (float): 2.9681374511827956
    'luck_factor': (float): -14.275417451182797
    'tiles_played_from_rack': (list, 4 items):
(str): "J"
(str): "I"
(str): "L"
        ... (and 1 more items)
    'leave': (list, 3 items):
(str): "L"
(str): "A"
(str): "N"
    'newly_placed': (list, 4 items):
(tuple, 3 items):
(int): 7
(int): 7
(str): "J"
(tuple, 3 items):
(int): 7
(int): 8
(str): "I"
(tuple, 3 items):
(int): 7
(int): 9
(str): "L"
        ... (and 1 more items)
    'start': (tuple, 2 items):
(int): 7
(int): 7
    'direction': (str): "H"
    'player': (int): 2
    'move_type': (str): "place"
    'rack': (list, 7 items):
(str): "R"
(str): "W"
(str): "D"
        ... (and 4 more items)
    'score': (float): 16.0
    'word': (str): "WILD"
    'positions': (list, 4 items):
(tuple, 3 items):
(int): 5
(int): 9
(str): "W"
(tuple, 3 items):
(int): 6
(int): 9
(str): "I"
(tuple, 3 items):
(int): 7
(int): 9
(str): "L"
        ... (and 1 more items)
    'blanks': (set): set() (empty)
    'drawn': (list, 3 items):
(str): "Z"
(str): "A"
(str): "A"
    'coord': (str): "J6"
    'word_with_blanks': (str): "WILD"
    'is_bingo': (bool): False
    'turn_duration': (float): 0.0
    'total_expected_draw_value': (float): 1.5162524514606743
    'luck_factor': (float): 2.7105889485393253
    'tiles_played_from_rack': (list, 3 items):
(str): "D"
(str): "I"
(str): "W"
    'leave': (list, 4 items):
(str): "R"
(str): "S"
(str): " "
        ... (and 1 more items)
    'newly_placed': (list, 3 items):
(tuple, 3 items):
(int): 8
(int): 9
(str): "D"
(tuple, 3 items):
(int): 6
(int): 9
(str): "I"
(tuple, 3 items):
(int): 5
(int): 9
(str): "W"
    'start': (tuple, 2 items):
(int): 5
(int): 9
    'direction': (str): "V"
    'player': (int): 1
    'move_type': (str): "place"
    'rack': (list, 7 items):
(str): "A"
(str): "N"
(str): "L"
        ... (and 4 more items)
    'score': (float): 24.0
    'word': (str): "VALIANT"
    'positions': (list, 7 items):
(tuple, 3 items):
(int): 4
(int): 8
(str): "V"
(tuple, 3 items):
(int): 5
(int): 8
(str): "A"
(tuple, 3 items):
(int): 6
(int): 8
(str): "L"
        ... (and 4 more items)
    'blanks': (set): set() (empty)
    'drawn': (list, 6 items):
(str): "O"
(str): "H"
(str): "V"
        ... (and 3 more items)
    'coord': (str): "I5"
    'word_with_blanks': (str): "VALIANT"
    'is_bingo': (bool): False
    'turn_duration': (float): 0.0
    'total_expected_draw_value': (float): 5.275505839534884
    'luck_factor': (float): 12.109374160465116
    'tiles_played_from_rack': (list, 6 items):
(str): "A"
(str): "L"
(str): "A"
        ... (and 3 more items)
    'leave': (list, 1 items):
(str): "T"
    'newly_placed': (list, 6 items):
(tuple, 3 items):
(int): 8
(int): 8
(str): "A"
(tuple, 3 items):
(int): 6
(int): 8
(str): "L"
(tuple, 3 items):
(int): 5
(int): 8
(str): "A"
        ... (and 3 more items)
    'start': (tuple, 2 items):
(int): 4
(int): 8
    'direction': (str): "V"
    ... (and 21 more items)
'final_scores_adjusted': (list, 2 items):
(float): 373.0
(float): 439.0
'game_mode_info':   'game_mode_str': (str): "AI vs AI"
  'practice_mode_str': (NoneType): None
'game_settings':   'use_endgame_solver': (bool): False
  'use_ai_simulation': (bool): False
  'is_ai_config': (list, 2 items):
(bool): True
(bool): True
  'letter_checks': (list, 4 items):
(bool): True
(bool): True
(bool): True
      ... (and 1 more items)
  'number_checks': (list, 6 items):
(bool): True
(bool): True
(bool): True
      ... (and 3 more items)
  'ai_simulation_parameters':     'num_candidates': (int): 10
    'num_opponent_sims': (int): 50
    'num_post_sim_candidates': (int): 10
  'bbb_7l_max_prob': (int): 1000
  'bbb_8l_max_prob': (int): 1000
--- Schema End ---


###############################################################
###############################################################
'''


import tkinter as tk
from tkinter import filedialog, scrolledtext
import os
import pickle
import csv
import pandas as pd # For statistical analysis


# =================================================================================================
# /////////////////////////////////////////////////////////////////////////////////////////////////
# --- CONFIGURATION & CONSTANTS ---
# /////////////////////////////////////////////////////////////////////////////////////////////////
# =================================================================================================

SGS_FILES_DIRECTORY = "/Users/gregmacbook/Documents/Batch Games"
OUTPUT_CSV_FILE = "batch_stats_summary.csv"
BINGO_MIN_TILES = 7 # Minimum number of tiles played to be considered a bingo

# --- Game Data Keys (based on observed .sgs file structure) ---
# These keys provide a single point of reference for the raw data structure.
# The ParsedGame class (Layer 2) will use these to abstract the data.
SGS_VERSION_KEY = 'sgs_version'
FULL_MOVE_HISTORY_KEY = 'full_move_history'
FINAL_SCORES_ADJUSTED_KEY = 'final_scores_adjusted'

MOVE_PLAYER_INDEX_KEY = 'player'
MOVE_SCORE_KEY = 'score'
MOVE_IS_BINGO_FLAG_KEY = 'is_bingo'
MOVE_TILES_PLAYED_KEY = 'tiles_played_from_rack'


# =================================================================================================
# /////////////////////////////////////////////////////////////////////////////////////////////////
# --- LAYER 1: DATA LOADING & PARSING (SGS Files -> Raw Game Object) ---
# /////////////////////////////////////////////////////////////////////////////////////////////////
# =================================================================================================

def load_sgs_file(filename, status_widget):
    """
    Loads a complete game state from an .sgs file using pickle.
    This is our primary Layer 1 component.
    """
    try:
        with open(filename, 'rb') as f_load:
            loaded_data = pickle.load(f_load)
        # Status update is now less critical here, but can be useful for debugging.
        # update_status(status_widget, f"Successfully loaded: {os.path.basename(filename)}")

        if not isinstance(loaded_data, dict):
            update_status(status_widget, f"Error: {os.path.basename(filename)} did not load as a dictionary.")
            return None
        return loaded_data
    except FileNotFoundError:
        update_status(status_widget, f"Error: File not found '{filename}'")
        return None
    except (pickle.UnpicklingError, EOFError) as e:
        update_status(status_widget, f"Error unpickling data from {os.path.basename(filename)}: {e}")
        return None
    except Exception as e:
        update_status(status_widget, f"Unexpected error loading {os.path.basename(filename)}: {e}")
        return None


# =================================================================================================
# /////////////////////////////////////////////////////////////////////////////////////////////////
# --- LAYER 2: GAME DATA ABSTRACTION (Raw Game Object -> Structured Game Object) ---
# /////////////////////////////////////////////////////////////////////////////////////////////////
# =================================================================================================

class ParsedGame:
    """
    A wrapper for the raw game_data dictionary loaded from an .sgs file.
    It provides a clean, stable interface for accessing game data, abstracting
    away the underlying dictionary keys.
    """
    def __init__(self, game_data, source_filename):
        self._data = game_data
        self._filename = os.path.basename(source_filename)

    def get_filename(self):
        """Returns the base filename of the source .sgs file."""
        return self._filename

    def is_valid(self):
        """
        Checks if the loaded game data contains the minimum required keys
        for basic statistical analysis.
        """
        if not self._data:
            return False
        
        final_scores = self._data.get(FINAL_SCORES_ADJUSTED_KEY)
        if final_scores is None or not isinstance(final_scores, list) or len(final_scores) < 2:
            print(f"Validation failed for {self._filename}: Missing or invalid '{FINAL_SCORES_ADJUSTED_KEY}'.")
            return False
            
        move_history = self._data.get(FULL_MOVE_HISTORY_KEY)
        if move_history is None or not isinstance(move_history, list):
            print(f"Validation failed for {self._filename}: Missing or invalid '{FULL_MOVE_HISTORY_KEY}'.")
            return False
            
        return True

    def get_final_scores(self):
        """Returns a list of final scores, e.g., [p1_score, p2_score]."""
        return self._data.get(FINAL_SCORES_ADJUSTED_KEY, [0, 0])

    def get_move_history(self):
        """Returns the full list of move dictionaries."""
        return self._data.get(FULL_MOVE_HISTORY_KEY, [])


# =================================================================================================
# /////////////////////////////////////////////////////////////////////////////////////////////////
# --- LAYER 3: STATISTIC CALCULATION ---
# /////////////////////////////////////////////////////////////////////////////////////////////////
# =================================================================================================

class BaseStatistic:
    """
    Abstract base class for a statistic calculator.
    Defines the interface that all concrete statistic classes must implement.
    """
    def get_column_names(self):
        """Returns a list of strings for the CSV header."""
        raise NotImplementedError("Subclasses must implement this method.")

    def calculate(self, parsed_game):
        """
        Takes a ParsedGame object and returns a dictionary of
        {column_name: value}.
        """
        raise NotImplementedError("Subclasses must implement this method.")

class GameIDStatistic(BaseStatistic):
    """Calculates the Game ID."""
    def get_column_names(self):
        return ["game_id"]

    def calculate(self, parsed_game):
        return {"game_id": parsed_game.get_filename()}

class PlayerScoreStatistic(BaseStatistic):
    """Calculates final scores for both players."""
    def get_column_names(self):
        return ["p1_score", "p2_score"]

    def calculate(self, parsed_game):
        scores = parsed_game.get_final_scores()
        return {"p1_score": scores[0], "p2_score": scores[1]}

class BingoCountStatistic(BaseStatistic):
    """Counts the number of bingos for each player."""
    def get_column_names(self):
        return ["p1_bingos", "p2_bingos"]

    def calculate(self, parsed_game):
        p1_bingos = 0
        p2_bingos = 0
        for move in parsed_game.get_move_history():
            if not isinstance(move, dict):
                continue

            is_bingo = move.get(MOVE_IS_BINGO_FLAG_KEY)
            player_idx = move.get(MOVE_PLAYER_INDEX_KEY)

            bingo_found = False
            if is_bingo is True:
                bingo_found = True
            elif is_bingo is None: # Fallback for older schemas
                tiles_played = move.get(MOVE_TILES_PLAYED_KEY, [])
                if isinstance(tiles_played, (list, str)) and len(tiles_played) >= BINGO_MIN_TILES:
                    bingo_found = True
            
            if bingo_found:
                if player_idx == 1:
                    p1_bingos += 1
                elif player_idx == 2:
                    p2_bingos += 1
        
        return {"p1_bingos": p1_bingos, "p2_bingos": p2_bingos}

class MaxTurnScoreStatistic(BaseStatistic):
    """Finds the single highest-scoring turn in the game."""
    def get_column_names(self):
        return ["game_max_turn_score"]

    def calculate(self, parsed_game):
        max_score = 0
        for move in parsed_game.get_move_history():
            if not isinstance(move, dict):
                continue
            
            turn_score = move.get(MOVE_SCORE_KEY, 0)
            if not isinstance(turn_score, (int, float)):
                turn_score = 0
            
            if turn_score > max_score:
                max_score = turn_score
        
        return {"game_max_turn_score": max_score}

# --- Registry of all statistics to be calculated ---
STATISTICS_TO_RUN = [
    GameIDStatistic(),
    PlayerScoreStatistic(),
    BingoCountStatistic(),
    MaxTurnScoreStatistic(),
]


# =================================================================================================
# /////////////////////////////////////////////////////////////////////////////////////////////////
# --- LAYER 4: CSV GENERATION & ORCHESTRATION ---
# /////////////////////////////////////////////////////////////////////////////////////////////////
# =================================================================================================

def process_all_sgs_files(directory, status_widget):
    """
    Orchestrates the entire process:
    1. Finds all .sgs files.
    2. For each file, creates a ParsedGame object.
    3. Runs all registered statistic calculators on it.
    4. Collects the results and writes them to a single CSV file.
    """
    update_status(status_widget, f"Starting processing of SGS files in: {directory}")
    sgs_files = [f for f in os.listdir(directory) if f.endswith(".sgs")]

    if not sgs_files:
        update_status(status_widget, "No .sgs files found in the directory.")
        return None

    all_games_data = []
    for sgs_file in sgs_files:
        filepath = os.path.join(directory, sgs_file)
        update_status(status_widget, f"Processing: {sgs_file}...")
        
        raw_game_data = load_sgs_file(filepath, status_widget)
        if not raw_game_data:
            update_status(status_widget, f"Failed to load or read {sgs_file}. Skipping.")
            continue

        parsed_game = ParsedGame(raw_game_data, sgs_file)
        if not parsed_game.is_valid():
            update_status(status_widget, f"Skipping {sgs_file} due to missing critical data.")
            continue

        # Calculate all stats for this game
        game_stats_row = {}
        for statistic_calculator in STATISTICS_TO_RUN:
            try:
                result = statistic_calculator.calculate(parsed_game)
                game_stats_row.update(result)
            except Exception as e:
                update_status(status_widget, f"Error calculating {type(statistic_calculator).__name__} for {sgs_file}: {e}")

        if game_stats_row:
            all_games_data.append(game_stats_row)

    if not all_games_data:
        update_status(status_widget, "No data successfully extracted from any SGS files.")
        return False

    # Write to CSV
    try:
        # Dynamically generate fieldnames from the statistic objects
        fieldnames = []
        for stat in STATISTICS_TO_RUN:
            fieldnames.extend(stat.get_column_names())

        with open(OUTPUT_CSV_FILE, 'w', newline='') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            writer.writerows(all_games_data)
        update_status(status_widget, f"Successfully wrote data for {len(all_games_data)} games to {OUTPUT_CSV_FILE}")
        return True # Indicates CSV was written
    except IOError as e:
        update_status(status_widget, f"Error writing to CSV {OUTPUT_CSV_FILE}: {e}")
        return False
    except Exception as e:
        update_status(status_widget, f"Unexpected error writing CSV: {e}")
        return False


# =================================================================================================
# /////////////////////////////////////////////////////////////////////////////////////////////////
# --- LAYER 5: POST-CSV ANALYSIS (Pandas) ---
# /////////////////////////////////////////////////////////////////////////////////////////////////
# =================================================================================================

def calculate_and_display_stats(status_widget):
    """
    Reads the generated CSV using Pandas and calculates/displays statistics.
    """
    try:
        df = pd.read_csv(OUTPUT_CSV_FILE)
    except FileNotFoundError:
        update_status(status_widget, f"Error: CSV file {OUTPUT_CSV_FILE} not found. Cannot calculate stats.")
        return
    except pd.errors.EmptyDataError:
        update_status(status_widget, f"Error: CSV file {OUTPUT_CSV_FILE} is empty. Cannot calculate stats.")
        return
    except Exception as e:
        update_status(status_widget, f"Error reading CSV with Pandas {OUTPUT_CSV_FILE}: {e}")
        return

    if df.empty:
        update_status(status_widget, "CSV file is empty. No statistics to calculate.")
        return

    num_games = len(df)
    update_status(status_widget, f"\n--- Statistics based on {num_games} games ---")

    # Cumulative average scores
    avg_p1_score = df['p1_score'].mean()
    avg_p2_score = df['p2_score'].mean()
    update_status(status_widget, f"Average P1 Score: {avg_p1_score:.2f}")
    update_status(status_widget, f"Average P2 Score: {avg_p2_score:.2f}")

    # Average bingos per game
    avg_p1_bingos = df['p1_bingos'].mean()
    avg_p2_bingos = df['p2_bingos'].mean()
    update_status(status_widget, f"Average P1 Bingos per Game: {avg_p1_bingos:.2f}")
    update_status(status_widget, f"Average P2 Bingos per Game: {avg_p2_bingos:.2f}")

    # Average of the "largest single score per game"
    avg_max_turn_score = df['game_max_turn_score'].mean()
    update_status(status_widget, f"Average Max Turn Score per Game: {avg_max_turn_score:.2f}")

    update_status(status_widget, "\n--- End of Statistics ---")


# =================================================================================================
# /////////////////////////////////////////////////////////////////////////////////////////////////
# --- LAYER 6: USER INTERFACE (Tkinter) & UTILITIES ---
# /////////////////////////////////////////////////////////////////////////////////////////////////
# =================================================================================================

def update_status(text_widget, message):
    """Appends a message to the status text widget and scrolls to the end."""
    text_widget.insert(tk.END, message + "\n")
    text_widget.see(tk.END)
    text_widget.update_idletasks() # Ensure GUI updates immediately

def start_processing(status_widget):
    """Main function called when the 'Gather Stats' button is pressed."""
    status_widget.delete('1.0', tk.END) # Clear previous status messages
    update_status(status_widget, "Process started...")

    # Check if directory exists
    if not os.path.isdir(SGS_FILES_DIRECTORY):
        update_status(status_widget, f"Error: Directory not found - {SGS_FILES_DIRECTORY}")
        update_status(status_widget, "Processing aborted.")
        return

    csv_written_successfully = process_all_sgs_files(SGS_FILES_DIRECTORY, status_widget)

    if csv_written_successfully:
        calculate_and_display_stats(status_widget)
    else:
        update_status(status_widget, "CSV file was not generated or is empty. Cannot calculate statistics.")

    update_status(status_widget, "\nProcessing finished.")

def start_schema_dump(status_widget):
    """
    Handles the 'Get Schema' button click. Prompts user for an .sgs file
    and then calls dump_sgs_schema to print its structure to the console.
    """
    status_widget.insert(tk.END, "\nAttempting to dump schema...\n")
    status_widget.see(tk.END)
    
    sgs_filepath = filedialog.askopenfilename(
        title="Select an .SGS File to Analyze Schema",
        initialdir=SGS_FILES_DIRECTORY, # Start in the default batch games directory
        filetypes=(("SGS files", "*.sgs"), ("All files", "*.*"))
    )

    if sgs_filepath: # If a file was selected
        update_status(status_widget, f"Selected file for schema dump: {sgs_filepath}")
        update_status(status_widget, "Schema will be printed to the CONSOLE / TERMINAL.")
        # Call the schema dumper function (which prints to console)
        dump_sgs_schema(sgs_filepath) 
        update_status(status_widget, "Schema dump to console complete.")
    else:
        update_status(status_widget, "Schema dump cancelled (no file selected).")

def dump_sgs_schema(sgs_filepath):
    """
    Loads a single .sGS file and prints its data structure (schema)
    to the console in a human-readable format.

    Args:
        sgs_filepath (str): The full path to the .sgs file to analyze.
    """
    print(f"\n--- Analyzing schema for: {sgs_filepath} ---")
    try:
        with open(sgs_filepath, 'rb') as f_load:
            game_data = pickle.load(f_load)
    except FileNotFoundError:
        print(f"Error: File not found '{sgs_filepath}'")
        return
    except (pickle.UnpicklingError, EOFError) as e:
        print(f"Error unpickling data from {sgs_filepath}: {e}")
        return
    except Exception as e:
        print(f"Unexpected error loading {sgs_filepath}: {e}")
        return

    if not isinstance(game_data, dict):
        print(f"Error: Loaded data from {sgs_filepath} is not a dictionary (Type: {type(game_data)}). Cannot dump schema.")
        return

    print("--- Schema Start ---")
    _recursive_print_schema(game_data, indent_level=0)
    print("--- Schema End ---")

def _recursive_print_schema(data_item, indent_level=0, current_path=""):
    """
    Helper function to recursively print the schema of a data item.
    """
    indent = "  " * indent_level
    MAX_LIST_ITEMS_TO_SHOW = 3 # Show first few items of a list
    MAX_STRING_LENGTH_TO_SHOW = 70 # Truncate long strings

    if isinstance(data_item, dict):
        if not data_item:
            print(f"{indent}{current_path}(dict): {{}} (empty)")
            return
        # print(f"{indent}{current_path}(dict):") # Optional: print dict path before its items
        for key, value in data_item.items():
            new_path = f"{current_path}.{key}" if current_path else key
            print(f"{indent}'{key}': ", end="") # Print key, then let recursive call print type/value
            _recursive_print_schema(value, indent_level + 1, new_path)
    
    elif isinstance(data_item, list):
        if not data_item:
            print(f"(list): [] (empty)")
        else:
            print(f"(list, {len(data_item)} items):")
            # Show type of first item, or first few items
            for i, item in enumerate(data_item[:MAX_LIST_ITEMS_TO_SHOW]):
                item_path_display = f"{current_path}[{i}]" # For context if needed, but can be verbose
                # print(f"{indent}  [{i}]: ", end="") # Print index, then let recursive call print type/value
                _recursive_print_schema(item, indent_level + 1, item_path_display)
            if len(data_item) > MAX_LIST_ITEMS_TO_SHOW:
                print(f"{indent}  ... (and {len(data_item) - MAX_LIST_ITEMS_TO_SHOW} more items)")
    
    elif isinstance(data_item, tuple):
        if not data_item:
            print(f"(tuple): () (empty)")
        else:
            print(f"(tuple, {len(data_item)} items):")
            for i, item in enumerate(data_item[:MAX_LIST_ITEMS_TO_SHOW]):
                item_path_display = f"{current_path}[{i}]"
                _recursive_print_schema(item, indent_level + 1, item_path_display)
            if len(data_item) > MAX_LIST_ITEMS_TO_SHOW:
                print(f"{indent}  ... (and {len(data_item) - MAX_LIST_ITEMS_TO_SHOW} more items)")

    elif isinstance(data_item, set):
        if not data_item:
            print(f"(set): set() (empty)")
        else:
            # Convert set to list for consistent display of first few items
            temp_list = list(data_item)
            print(f"(set, {len(temp_list)} items): {{")
            for i, item in enumerate(temp_list[:MAX_LIST_ITEMS_TO_SHOW]):
                # Sets don't have a path for items, just show the item itself
                _recursive_print_schema(item, indent_level + 1, "") # No path for set items
            if len(temp_list) > MAX_LIST_ITEMS_TO_SHOW:
                print(f"{indent}  ... (and {len(temp_list) - MAX_LIST_ITEMS_TO_SHOW} more items)")
            print(f"{indent}}}")


    elif isinstance(data_item, str):
        if len(data_item) > MAX_STRING_LENGTH_TO_SHOW:
            print(f"(str): \"{data_item[:MAX_STRING_LENGTH_TO_SHOW]}...\" (truncated)")
        else:
            print(f"(str): \"{data_item}\"")
    
    elif isinstance(data_item, bool):
        print(f"(bool): {data_item}")
        
    elif isinstance(data_item, (int, float)):
        print(f"({type(data_item).__name__}): {data_item}")
        
    elif data_item is None:
        print(f"(NoneType): None")
        
    else:
        # For any other types, just print their type and a string representation
        print(f"({type(data_item).__name__}): {str(data_item)}")

def setup_gui():
    """Sets up and runs the Tkinter GUI."""
    root = tk.Tk()
    root.title("Scrabble Batch Stats Processor")

    main_frame = tk.Frame(root, padx=10, pady=10)
    main_frame.pack(fill=tk.BOTH, expand=True)

    # Directory Info Label
    dir_label = tk.Label(main_frame, text=f"Looking for .sgs files in: {SGS_FILES_DIRECTORY}")
    dir_label.pack(pady=(0, 10))
    
    output_csv_label = tk.Label(main_frame, text=f"Output CSV will be: {OUTPUT_CSV_FILE}")
    output_csv_label.pack(pady=(0,10))

    # Status Text Area
    status_text = scrolledtext.ScrolledText(main_frame, wrap=tk.WORD, height=20, width=80)
    status_text.pack(pady=(0, 10), fill=tk.BOTH, expand=True)

    # --- Buttons ---
    button_frame = tk.Frame(main_frame)
    button_frame.pack(fill=tk.X)

    gather_button = tk.Button(button_frame, text="Gather Stats",
                              command=lambda: start_processing(status_text))
    gather_button.pack(side=tk.LEFT, expand=True, fill=tk.X, padx=5)

    schema_button = tk.Button(button_frame, text="Get Schema from File",
                              command=lambda: start_schema_dump(status_text))
    schema_button.pack(side=tk.LEFT, expand=True, fill=tk.X, padx=5)
    
    update_status(status_text, "Welcome to the Scrabble Batch Stats Processor.")
    update_status(status_text, "Click 'Gather Stats' to process batch files.")
    update_status(status_text, "Click 'Get Schema from File' to analyze an .sgs file structure (output to console).")

    root.mainloop()


# =================================================================================================
# /////////////////////////////////////////////////////////////////////////////////////////////////
# --- MAIN EXECUTION ---
# /////////////////////////////////////////////////////////////////////////////////////////////////
# =================================================================================================

if __name__ == "__main__":
    setup_gui()
